// FILE: server/src/index.ts
import express from "express";
import cors from "cors";
import Database from "better-sqlite3";
import fs from "node:fs";
import path from "node:path";
import { runAegisCli } from "./cliRunner.js";
import { ledgerMiddleware } from "./ledger.js";
import { ArbiterOrchestrator } from "../../src/kernal/orchestrator.js";
import { TensorRepository } from "../../src/kernal/storage/tensorRepository.js";
import { ResonanceService } from "../../src/kernal/analysis/resonanceServices.js";
import { MirrorManager } from "../../src/modules/mirror/mirrorManager.js";
import { SovereigntyProgressService } from "../../src/modules/mirror/progressService.js";
import { witnessEmitter } from "../../src/witness.js";
const app = express();
const dbPath = path.join(process.cwd(), "data", "aegis-kernel.sqlite");
const dbDir = path.dirname(dbPath);
if (!fs.existsSync(dbDir)) {
    fs.mkdirSync(dbDir, { recursive: true });
}
const db = new Database(dbPath);
db.pragma("journal_mode = WAL");
db.pragma("foreign_keys = ON");
// NOTE: This path assumes you're running the server with CWD=server/
// and that the schema lives at: ../src/kernal/storage/schema.sql
const schemaPath = path.join(process.cwd(), "..", "src", "kernal", "storage", "schema.sql");
const schemaSql = fs.readFileSync(schemaPath, "utf8");
db.exec(schemaSql);
db.exec("CREATE TABLE IF NOT EXISTS sessions (id TEXT PRIMARY KEY);");
const tensorRepo = new TensorRepository(db);
const resonance = new ResonanceService(tensorRepo);
const orchestrator = new ArbiterOrchestrator(tensorRepo, resonance, db);
const mirrorManager = new MirrorManager(orchestrator);
const progressService = new SovereigntyProgressService(tensorRepo);
app.use(cors());
app.use(express.json({ limit: "2mb" }));
/**
 * Root route (useful when reverse-proxied by nginx as /api -> /)
 * This prevents "Cannot GET /" confusion for testers/researchers.
 */
app.get("/", (_req, res) => {
    res.status(200).json({
        ok: true,
        service: "aegis-arbiter-server",
        status: "online",
        routes: {
            ping: "/api/ping",
            analyze: "/api/analyze"
        },
        note: "This server is typically reverse-proxied. In Docker, the UI proxies /api/* to this service.",
        timestamp: new Date().toISOString()
    });
});
/**
 * Simple health endpoint (common convention)
 */
app.get("/health", (_req, res) => {
    res.status(200).json({
        ok: true,
        status: "healthy",
        timestamp: new Date().toISOString()
    });
});
app.get("/api/ping", (_req, res) => {
    res.json({
        ok: true,
        status: "ready",
        detail: "In-process analyzer active (no external CLI required).",
        timestamp: new Date().toISOString()
    });
});
app.get("/api/ledger", ledgerMiddleware(tensorRepo));
app.get("/api/progress", async (req, res) => {
    const sessionId = (req.query?.sessionId ?? "").toString();
    if (!sessionId) {
        return res.status(400).json({ ok: false, error: "Missing sessionId." });
    }
    try {
        const trend = await progressService.getEvolutionTrend(sessionId);
        res.json({ ok: true, session_id: sessionId, trend });
    }
    catch (error) {
        res.status(500).json({ ok: false, error: "Progress Retrieval Fractured" });
    }
});
app.post("/api/mirror/reflect", async (req, res) => {
    const sessionId = (req.body?.sessionId ?? "").toString();
    const text = (req.body?.text ?? "").toString();
    if (!sessionId || !text) {
        return res.status(400).json({ ok: false, error: "Missing sessionId or text." });
    }
    try {
        const result = await mirrorManager.reflect(sessionId, text);
        res.json({ ok: true, ...result });
    }
    catch (error) {
        res.status(500).json({ ok: false, error: "Mirror Reflection Fractured" });
    }
});
app.post("/api/mirror/reflect-media", express.raw({
    type: [
        "audio/webm",
        "video/webm",
        "audio/wav",
        "audio/mpeg",
        "video/mp4",
        "application/octet-stream"
    ],
    limit: "50mb"
}), async (req, res) => {
    const sessionId = (req.query?.sessionId ?? "").toString();
    const sttUrl = process.env.AEGIS_STT_URL?.trim() || "http://localhost:8000/transcribe";
    if (!sessionId) {
        return res.status(400).json({ ok: false, error: "Missing sessionId." });
    }
    if (!req.body || req.body.length === 0) {
        return res.status(400).json({ ok: false, error: "Missing media payload." });
    }
    try {
        const sttResponse = await fetch(sttUrl, {
            method: "POST",
            headers: {
                "Content-Type": req.headers["content-type"] ?? "application/octet-stream"
            },
            body: req.body
        });
        if (!sttResponse.ok) {
            const errorText = await sttResponse.text().catch(() => "");
            return res.status(502).json({
                ok: false,
                error: "Transcription service failed.",
                detail: errorText
            });
        }
        const sttPayload = (await sttResponse.json());
        const transcript = (sttPayload?.text ?? "").toString().trim();
        if (!transcript) {
            return res.status(422).json({ ok: false, error: "Empty transcript returned." });
        }
        const result = await mirrorManager.reflect(sessionId, transcript);
        res.json({ ok: true, transcript, ...result });
    }
    catch (error) {
        res.status(500).json({ ok: false, error: "Mirror Media Reflection Fractured" });
    }
});
app.get("/api/witness", (req, res) => {
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Accel-Buffering", "no");
    if (typeof res.flushHeaders === "function") {
        res.flushHeaders();
    }
    const send = (payload) => {
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
    };
    const unsubscribe = witnessEmitter.on("resonance_event", send);
    const keepAlive = setInterval(() => {
        res.write(": keep-alive\n\n");
    }, 15000);
    req.on("close", () => {
        clearInterval(keepAlive);
        unsubscribe();
        res.end();
    });
});
function buildSummary(json) {
    const mode = json?.mode ?? "rbc";
    const flagged = Boolean(json?.flagged);
    const total = json?.score?.total;
    const findingsCount = Array.isArray(json?.findings) ? json.findings.length : 0;
    const base = flagged
        ? `⚠️ ${findingsCount} findings (see details)`
        : `✅ No issues found`;
    return `${mode.toUpperCase()} ANALYSIS SUMMARY: ${base} (${total} total points)`;
}
app.post("/api/analyze", async (req, res) => {
    try {
        const mode = (req.body?.mode ?? "rbc");
        const prompt = (req.body?.prompt ?? "").toString();
        const notepad = (req.body?.notepad ?? "").toString();
        const analysis = await runAegisCli({ mode, prompt, notepad });
        res.json({ ok: true, summary: buildSummary(analysis), ...analysis });
    }
    catch (error) {
        res.status(500).json({ ok: false, error: "Aegis analysis failed." });
    }
});
const port = Number(process.env.PORT ?? 8787);
app.listen(port, () => {
    console.log(`[aegis-arbiter-server] listening on http://localhost:${port}`);
});
//# sourceMappingURL=index.js.map